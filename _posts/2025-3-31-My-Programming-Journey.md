---
layout: post
title:  "My Programming Journey"
background: "/assets/imgs/braindump.png"
---

I recently had a friend ask me what I like about software engineering. In short, I think solving problems
is fun, writing code feels cool, and it gives me the tools to change the world. To better explain, I'll
share my journey into programming, computer science, and software engineering.

As a kid, I saw plenty of TV shows where programmers would upgrade a robot, or hack something, to save
the day in the nick of time; I admired those computer-nerd characters, and hoped to one day be as smart
and cool as them. Of course, it didn't occur to me at the time that the family computer was all I would
need to start learning how to write code. I just assumed that kind of knowledge was too advanced to
be found online; that it would be like trying to learn brain surgery from Wikipedia articles.
I had no idea what computer programming was actually like until the latter half of high school.

In my junior year of high school, my friend Chris asked me to join his First Robotics Competition (FRC) team.
Robots sounded super cool, so I signed up, and was put to work on the construction team with the rest of the unskilled
recruits, cutting many, many aluminum pipes with a hand saw. Between the times when things needed sawing or ratcheting,
I noticed my friend Chris was doing the much cooler sounding work of programming our robot, giving it a
rudimentary autonomous mode, and the ability for us to control it with a playstation controller. I was so curious how
he did it, but all his code was just wizardry to me. The following year,
I managed to convince him to teach me computer programming so I could join the programming team. Looking back
on it, Chris actually did a pretty good job of teaching me the basics of Java, but there was
only so much that could stick in my brain after 2 or 3 white-board lessons without practice. I understood some of
the most basic syntax, but I still had no idea what I was doing most of the time. By the end of the season, I
think I might have programmed the robot to turn left. (The rest of the basic coding work was split among the other
kids on the team, and Chris handled most things more complex than multiplying some numbers.) But by golly did that robot turn
left when we sent it onto the FRC battlefield, and I felt very proud that the tiny amount of code I wrote worked as intended.
It felt magical that I'd typed some esoteric runes into the computer, and was able to see our robot respond accordingly,
just like the hackers on TV (only I wrote code a lot slower and the changes were less impressive).

I'd had my first taste of computer programming, and with my new-found confidence, I was itching to see what else I could do.
For my AP Physics final project, I decided I would build a self-driving RC car using my sick hacker skills. I bought
a shitty RC car from Target, and borrowed an Arduino microcontroller and an ultrasonic distance sensor from Chris. 
Over the course of a month, I figured out how to read the distance measurements from the sensor and send signals to the wheels
using wires I'd pulled off the car's PCB. In the end, the car looked like a skinned WALL-E; tangled and exposed wires everywhere, with the distance sensor like big round eyes on the front. On
presentation day, I took the whole class into the hallway, and activated my self-driving car. I half expected it to drive around
the whole school, but after it detected the first obstacle in its path, it took a hard left into the lockers. That was
certainly a lesson in testing my software thoroughly before doing a live demo. I was
a little embarrassed, and confused about why it didn't turn away from the lockers, but mostly I was proud of
hacking the Arduino onto the random RC car and being able to control it at all. Figuring out how to build the car
and steer it with software all on my own felt incredible.

After that, I started thinking I might be able to program my own phone. During the summer before I went to college, I attempted to learn how to make an iOS app. Since I had a Mac
and an iPhone at the time, I imagined I had all the tools and skills I would need to make some kind of game. I started
following an online class for how to build a poker game in iOS, and was immediately dumbfounded by the lack of any programming
language for me to write or understand. I now know the online class was using the Interface Builder tool to drag-and-drop
everything for the app UI, but at the time, I was very confused that none of my coding knowledge from FRC was helpful in
making the app, and I had no idea how all this dragging and dropping was related to coding. At this point, I felt lost. I'd barely understood how code in a text file
accomplished anything, and now this drag-and-drop editor was completely opaque to me; I couldn't reason about how to do
anything that wasn't explicitly following the tutorial step-by-step. I knew I'd never be able to make my own game that way, and I gave up on the class before they even added suits to the cards.

Heading into college, I didn't know what I wanted to major in; I was open to anything that didn't involve literary analysis.
I entered my college's intro Computer Science course with hopes of relearning programming from the ground up;
this time I wanted to understand how everything worked so that I would be able to program anything I wanted.
I still remember my professor warning jokingly that "you'll get hooked on the dopamine hit of solving a problem with code."
And in my case at least, he was right. Figuring out how to translate logical steps in my head into code that could accomplish
any task set before me felt like a super-power. When I first learned how to use the terminal to interact
with my computer, I felt like I'd unlocked a whole new level of cool, since it looked just like the hacker scenes from TV.
After realizing I liked, but didn't love, the other subjects I was studying, I decided to major in computer science. 
Each of my classes gave me a better understanding of how to solve problems, and how to use computers to solve them efficiently.
But I had yet to write a program that was useful outside of solving some homework assignment.

My first taste of software engineering was at the end of my second year of college, when a group of friends invited me to join
their startup, GrammieGram. GrammieGram was a 1-way messaging website, designed for old people who couldn't or wouldn't
use email or texting, to easily receive messages from family or friends. I define software engineering as programming maintainable software for others, often as part of a team. 
Before GrammieGram, I'd never written any code that was intended to be useful for someone else, and certainly nothing that I would ever update or maintain. 
For the first time, I wrote tests for my code, and felt huge satisfaction whenever they would catch dumb mistakes my teammates or I had made.
Over that summer, we ran a little beta test group at a local retirement home, and I got to meet people that were using code I wrote,
and speak with them about how I could improve our product for them. We weren't always able to accomplish what they asked for, but I loved
when we could all work together to add a feature that a real user had requested. When school started up again in the fall, we lost
the time and motivation to keep working on GrammieGram, but during that period when our little startup team was hyper focused
on building something useful, I felt incredibly fulfilled. From then on, I knew that wanted to write more code that could help
people solve their real-life problems.

--- 

There are a lot of things that I like about programming and software engineering. I like building things, I like figuring out how things work,
I like fixing things, I like to solve other people's problems. And there are so many cool things that can
be done with programming knowledge! The map of computer science applications below only scratches the surface of all the amazing things that can be done
by programming a computer.

<img alt="Map of computer science topics" src="https://i.imgur.com/TFwOLXM.jpeg" width="100%">

Having the ability to program my computer to do anything I want it to is
incredibly rewarding to me, not to mention useful. I can automate tedious tasks, debug my own computer issues,
even build my own website and know exactly how it works. We depend more on computers and the internet
every day, and I enjoy that programming helps me better understand and navigate this expanding digital world.

